<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Vocal → Lead Sheet (Fix VexFlow)</title>
<style>
  :root { --bg:#0d0f14; --fg:#e7ecf3; --muted:#98a2b3; --accent:#7aa2ff; --warn:#ffb020; }
  body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:var(--bg); color:var(--fg); }
  header { padding:16px 20px; border-bottom:1px solid #1c2230; display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
  header h1 { font-size:18px; margin:0; }
  main { padding:16px; display:grid; gap:16px; max-width:1100px; margin:auto; }
  .card { background:#121623; border:1px solid #1c2230; border-radius:12px; padding:16px; }
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
  .status { font-size:13px; }
  .grid { display:grid; gap:12px; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); }
  label { font-size:13px; color:var(--muted); display:block; margin-bottom:6px; }
  input[type="file"] { color:var(--fg); }
  button { background:#1b2336; color:var(--fg); border:1px solid #2a3551; padding:10px 14px; border-radius:10px; cursor:pointer; }
  button:disabled { opacity:0.5; cursor:not-allowed; }
  button.primary { background:var(--accent); color:#071225; border:none; }
  .small { font-size:12px; color:var(--muted); }
  .divider { height:1px; background:#1c2230; margin:12px 0; }
  #vfPreview { background:#0e1424; border:1px dashed #2a3551; border-radius:10px; padding:10px; overflow:auto; max-height:65vh; }
  pre { margin:0; white-space:pre-wrap; }
  .dropzone { border:2px dashed #2a3551; border-radius:10px; padding:14px; text-align:center; color:#98a2b3; }
  .dropzone.drag { border-color:#7aa2ff; color:#e7ecf3; }
  .warn { background:#2a1f12; border:1px solid #5a3a14; color:#ffd58a; padding:10px 12px; border-radius:10px; }
</style>
</head>
<body>
<header>
  <h1>Vocal → Lead Sheet (Fix VexFlow)</h1>
  <span class="small">HTTPS page + HTTPS stem tunnel required</span>
</header>

<main>
  <section class="card">
    <div class="grid">
      <div>
        <label>Upload audio (WAV/MP3/AAC)</label>
        <div class="row">
          <input id="fileInput" type="file" accept=".wav,audio/wav,audio/*" />
          <button id="allFilesBtn" title="If the picker hides your .wav">Pick from all files</button>
          <input id="fileInputAll" type="file" accept="*/*" style="display:none;" />
        </div>
        <div id="dropzone" class="dropzone" style="margin-top:8px;">Drag & drop your audio here</div>
        <audio id="player" controls style="margin-top:8px; width:100%"></audio>
        <div class="small" style="margin-top:6px;">
          On iPhone, use Files → <b>On My iPhone</b> / <b>iCloud Drive</b>. Some app folders are hidden from the picker.
        </div>
      </div>

      <div>
        <label>Local Stem Helper (Demucs)</label>
        <div class="grid">
          <div>
            <label class="small">Server URL (must be <b>https://</b>)</label>
            <input id="stemUrl" type="text" placeholder="https://abc123.ngrok-free.app" />
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <button id="healthBtn">Health Check</button>
          <button id="separateBtn">Separate Vocals (Local)</button>
        </div>
        <div class="small" style="margin-top:6px;">
          Run <code>stem_helper.py</code> locally, then: <code>ngrok http 8765</code>. Paste the <b>https</b> URL here.
        </div>
      </div>

      <div>
        <label>Quantization & musical settings</label>
        <div class="grid">
          <div><label class="small">Grid</label>
            <select id="gridDen">
              <option value="8">1/8</option>
              <option value="12">1/12 (triplet 8ths)</option>
              <option value="16" selected>1/16</option>
              <option value="24">1/24 (triplet 16ths)</option>
              <option value="32">1/32</option>
            </select></div>
          <div><label class="small">Min note (ms)</label><input id="minDurMs" type="number" value="140"></div>
          <div><label class="small">Gap→rest (ms)</label><input id="gapMs" type="number" value="120"></div>
          <div><label class="small">Snap vibrato (semi)</label><input id="vibratoSemi" type="number" value="0.40" step="0.05"></div>
          <div><label class="small">Tempo (BPM; blank=auto)</label><input id="tempoBpm" type="number" min="40" max="240" step="1" placeholder="auto"></div>
          <div><label class="small">Key (auto or e.g. G major)</label><input id="forceKey" type="text" placeholder="auto"></div>
          <div><label class="small">Meter</label>
            <select id="meterSel">
              <option value="4/4" selected>4/4</option>
              <option value="3/4">3/4</option>
              <option value="6/8">6/8</option>
            </select></div>
        </div>
      </div>
    </div>

    <div class="divider"></div>
    <div class="row">
      <button id="analyzeBtn" class="primary">Analyze → Notes</button>
      <button id="engraveBtn" disabled>Engrave (Preview)</button>
      <button id="downloadPdf" disabled>Download PDF</button>
      <div id="status" class="status">Idle.</div>
    </div>
  </section>

  <section class="card">
    <h3>Preview</h3>
    <div id="vfPreview"></div>
  </section>

  <section class="card">
    <h3>Diagnostics</h3>
    <pre id="log" class="small mono"></pre>
  </section>
</main>

<!-- Deps -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ml5@0.12.2/dist/ml5.min.js"></script>

<!-- VexFlow: use a build that places a global. If one CDN fails, you still won't crash. -->
<script src="https://unpkg.com/vexflow@4.2.3/releases/vexflow-debug.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.2.1/dist/svg2pdf.min.js"></script>

<script>
/* ---------- Hardening & logging ---------- */
const logEl = document.getElementById('log');
function logln(...a){ logEl.textContent += a.join(' ') + '\\n'; logEl.scrollTop = logEl.scrollHeight; }
window.addEventListener('error', e=> logln('window.error:', e.message||e));
window.addEventListener('unhandledrejection', e=> logln('unhandledrejection:', e.reason?.message||e.reason||e));

/* ---------- UI refs ---------- */
const fileInput = document.getElementById('fileInput');
const fileInputAll = document.getElementById('fileInputAll');
const allFilesBtn = document.getElementById('allFilesBtn');
const dropzone = document.getElementById('dropzone');
const player = document.getElementById('player');
const statusEl = document.getElementById('status');
const analyzeBtn = document.getElementById('analyzeBtn');
const engraveBtn = document.getElementById('engraveBtn');
const downloadPdfBtn = document.getElementById('downloadPdf');

const gridDen = document.getElementById('gridDen');
const minDurMs = document.getElementById('minDurMs');
const gapMs = document.getElementById('gapMs');
const vibratoSemi = document.getElementById('vibratoSemi');
const tempoBpm = document.getElementById('tempoBpm');
const forceKey = document.getElementById('forceKey');
const meterSel = document.getElementById('meterSel');

const stemUrl = document.getElementById('stemUrl');
const separateBtn = document.getElementById('separateBtn');
const healthBtn = document.getElementById('healthBtn');

let srcBlob = null;     // uploaded or original
let vocalsBlob = null;  // separated vocals
let lastNotes = [];
let lastPlan = null;

/* ---------- File picking & DnD ---------- */
function useBlob(b, label='blob'){
  srcBlob = b;
  player.src = URL.createObjectURL(b); player.load();
  logln('Loaded:', label, (b.size/1024/1024).toFixed(2), 'MB');
  statusEl.textContent = 'Audio loaded.';
}
fileInput.addEventListener('change', e=>{
  const f = e.target.files[0]; if(!f) return; useBlob(f, f.name);
});
allFilesBtn.addEventListener('click', ()=> fileInputAll.click());
fileInputAll.addEventListener('change', e=>{
  const f = e.target.files[0]; if(!f) return; useBlob(f, f.name);
});
;['dragenter','dragover'].forEach(ev=> dropzone.addEventListener(ev, e=>{ e.preventDefault(); dropzone.classList.add('drag'); }));
;['dragleave','drop'].forEach(ev=> dropzone.addEventListener(ev, e=>{ e.preventDefault(); dropzone.classList.remove('drag'); }));
dropzone.addEventListener('drop', e=>{
  const f = e.dataTransfer.files && e.dataTransfer.files[0];
  if(f) useBlob(f, f.name);
});

/* ---------- Helpers ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function median(a){ const s=[...a].sort((x,y)=>x-y); const n=s.length; return n? (n%2? s[(n-1)/2] : 0.5*(s[n/2-1]+s[n/2])) : 0; }

/* ---------- Preprocess (center boost + HPF/LPF) ---------- */
async function preprocessAudioToBuffer(blob){
  const center = 'mild'; const hpf=80; const lpf=6000;
  const OffAC = window.OfflineAudioContext || window.webkitOfflineAudioContext;
  const ac = new OffAC(2, 44100*60, 44100);
  const data = await blob.arrayBuffer();
  const buf = await ac.decodeAudioData(data);
  const src = ac.createBufferSource(); src.buffer = buf;

  const splitter = ac.createChannelSplitter(2);
  const chL = ac.createGain(), chR = ac.createGain();
  const merger = ac.createChannelMerger(2);
  src.connect(splitter);
  splitter.connect(chL,0); splitter.connect(chR,1);

  const midGain = ac.createGain(); const sideGain = ac.createGain();
  const inv = ac.createGain(); inv.gain.value = -1;
  const midBus = ac.createGain(), sideBus = ac.createGain();
  chL.connect(midBus); chR.connect(midBus);
  chL.connect(sideBus); chR.connect(inv); inv.connect(sideBus);

  midGain.gain.value = 0.5;
  sideGain.gain.value = (center==='strong')? 0.1 : (center==='mild'? 0.4 : 1.0);
  midBus.connect(midGain); sideBus.connect(sideGain);

  const mix = ac.createGain(); midGain.connect(mix); sideGain.connect(mix);
  const hpfNode = ac.createBiquadFilter(); hpfNode.type='highpass'; hpfNode.frequency.value = hpf;
  const lpfNode = ac.createBiquadFilter(); lpfNode.type='lowpass';  lpfNode.frequency.value = lpf;
  mix.connect(hpfNode); hpfNode.connect(lpfNode);
  lpfNode.connect(merger,0,0); lpfNode.connect(merger,0,1);
  merger.connect(ac.destination);

  src.start();
  const out = await ac.startRendering();
  return out;
}

/* ---------- f0 with ml5 CREPE ---------- */
async function estimateF0TrackFromBuffer(audioBuffer){
  return new Promise(async (resolve, reject)=>{
    try{
      const AC = window.AudioContext || window.webkitAudioContext;
      const ac = new AC();
      await ac.resume();
      const src = ac.createBufferSource(); src.buffer = audioBuffer;
      const dst = ac.createMediaStreamDestination();
      src.connect(dst); src.start();

      const modelUrl = 'https://cdn.jsdelivr.net/npm/ml5@0.12.2/models/crepe/';
      const pitch = await ml5.pitchDetection(modelUrl, ac, dst.stream, ac.sampleRate);
      logln('CREPE loaded at', ac.sampleRate, 'Hz');

      const duration = audioBuffer.duration;
      const hop = 0.02;
      const f0 = [];
      let t=0;

      const timer = setInterval(()=>{
        pitch.getPitch((err, frequency)=>{
          if(err){ logln('pitch err', err); }
          f0.push({t, hz: frequency||0});
        });
        t += hop;
        if(t >= duration){
          clearInterval(timer);
          try{ src.stop(); ac.close(); }catch{}
          resolve(f0);
        }
      }, hop*1000);
    }catch(e){ reject(e); }
  });
}

/* ---------- Note segmentation, tempo, key ---------- */
function segmentNotesFromF0(f0, {gridDen, minDurMs, gapMs, vibratoSemi}){
  if(!f0 || !f0.length) return [];
  const hop=0.02;
  const minFrames = Math.max(1, Math.round((minDurMs/1000)/hop));
  const gapFrames = Math.max(1, Math.round((gapMs/1000)/hop));
  const midiSeries = f0.map(d => d.hz>0 ? 69 + 12*Math.log2(d.hz/440) : 0);

  const smoothed = midiSeries.map((m,i,arr)=>{
    if(m===0) return 0;
    const neigh = arr.slice(Math.max(0,i-2), Math.min(arr.length,i+3)).filter(x=>x>0);
    const med = median(neigh);
    return (Math.abs(m-med) < vibratoSemi)? med : m;
  });

  const notes=[]; let i=0;
  while(i<smoothed.length){
    if(smoothed[i]===0){ i++; continue; }
    const base = Math.round(smoothed[i]);
    let j=i+1, gaps=0;
    while(j<smoothed.length){
      const m = smoothed[j];
      if(m===0){ gaps++; if(gaps>gapFrames) break; }
      else { if(Math.abs(Math.round(m)-base) > 0.5) break; }
      j++;
    }
    const len=j-i;
    if(len>=minFrames){ notes.push({midi:base, startSec:i*hop, durSec:len*hop}); }
    i=j+1;
  }
  return notes;
}
function estimateTempoBpm(notes){
  if(notes.length<4) return 110;
  const iois=[]; for(let i=1;i<notes.length;i++) iois.push(notes[i].startSec-notes[i-1].startSec);
  const med = median(iois); if(!isFinite(med)||med<=0) return 110;
  let bpm = 60/med; const c=[bpm/2,bpm,bpm*2,bpm*1.5].map(x=>clamp(x,40,200));
  c.sort((a,b)=>Math.abs(a-110)-Math.abs(b-110)); return Math.round(c[0]);
}
function detectKey(notes){
  if(!notes.length) return 'C major';
  const pc=new Array(12).fill(0);
  for(const n of notes) pc[n.midi%12]+=n.durSec;
  const names=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const major=[2,0,2,0,2,2,0,2,0,2,0,2];
  let best='C major', bs=-1;
  for(let t=0;t<12;t++){
    const profile=major.map((v,i)=>major[(i-t+12)%12]);
    const s=pc.reduce((s,v,i)=>s+v*profile[i],0);
    if(s>bs){ bs=s; best=names[t]+' major'; }
  }
  return best;
}

/* ---------- MusicXML ---------- */
function buildMusicXML(notes, plan){
  const {meter, tempoBpm, keySignature, gridDen}=plan;
  const qps = tempoBpm/60;
  const quant = q=>Math.max(1/gridDen, Math.round(q*gridDen)/gridDen);
  let [num,den]=meter.split('/').map(Number); if(!num||!den){num=4;den=4;}
  const keyMap={'C':0,'G':1,'D':2,'A':3,'E':4,'B':5,'F#':6,'C#':7,'F':-1,'Bb':-2,'Eb':-3,'Ab':-4,'Db':-5,'Gb':-6,'Cb':-7};
  const ks=(keySignature||'C major').split(' '); const tonic=ks[0]||'C'; const mode=(ks[1]||'major').toLowerCase();
  const fifths=keyMap[tonic]??0;

  const measureQL = num*(4/den);
  let qTime=0; const xmlEvents=[];
  for(const n of notes){
    const startQ = n.startSec*qps;
    const durQ = quant(n.durSec*qps);
    if(startQ>qTime+1e-3){ const restQ=startQ-qTime; xmlEvents.push(...emitRest(restQ,measureQL)); qTime=startQ; }
    xmlEvents.push(...emitNote(n.midi,durQ,measureQL)); qTime+=durQ;
  }
  const header=`<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 4.0 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="4.0">
 <part-list><score-part id="P1"><part-name>Vocal</part-name></score-part></part-list>
 <part id="P1">`;
  const meases = wrap(xmlEvents, measureQL, {num,den,fifths,mode,tempoBpm});
  const footer=`</part></score-partwise>`;
  return header+meases+footer;
}
function wrap(xmlNotes, measureQL, m){
  let out='',cur=0,idx=1;
  function open(i){ return `\n  <measure number="${i}">
    <attributes>
      <divisions>480</divisions>
      <key><fifths>${m.fifths}</fifths><mode>${m.mode}</mode></key>
      <time><beats>${m.num}</beats><beat-type>${m.den}</beat-type></time>
      <clef><sign>G</sign><line>2</line></clef>
    </attributes>
    <direction placement="above"><direction-type><metronome><beat-unit>quarter</beat-unit><per-minute>${m.tempoBpm}</per-minute></metronome></direction-type></direction>`;}
  out+=open(idx);
  for(const x of xmlNotes){
    if(x.type==='bar'){ out+=`\n  </measure>`; out+=open(++idx); cur=0; }
    else { out+=x.xml; cur+=x.ql; if(Math.abs(cur-measureQL)<1e-3){ out+=`\n  <barline location="right"><bar-style>regular</bar-style></barline>\n  </measure>`; out+=open(++idx); cur=0; } }
  }
  out+=`\n  </measure>\n`; return out;
}
function qToDiv(q){ return Math.round(q*480); }
function durToType(div){
  const table=[[1920,'whole'],[960,'half'],[480,'quarter'],[240,'eighth'],[120,'16th'],[60,'32nd']];
  for(const [d,t] of table){ if(div>=d-5) return {type:t,dots:(Math.abs(div-d*1.5)<5)?1:0}; }
  return {type:'16th',dots:0};
}
function midiPitch(m){
  const steps=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const step=steps[m%12], alter=step.includes('#')?1:0, base=step.replace('#',''); const octave=Math.floor(m/12)-1;
  return {step:base, alter, octave};
}
function emitNote(midi,ql,measureQL){
  const parts=[]; let rem=ql;
  while(rem>0){
    const take=Math.min(rem,measureQL); const div=qToDiv(take); const {type,dots}=durToType(div); const p=midiPitch(midi);
    let xml=`\n  <note><pitch><step>${p.step}</step>${p.alter?`<alter>${p.alter}</alter>`:''}<octave>${p.octave}</octave></pitch><duration>${div}</duration><type>${type}</type>`;
    if(dots) xml+=`<dot/>`; xml+=`</note>`; parts.push({xml,ql:take});
    rem-=take; if(rem>1e-6) parts.push({type:'bar'});
  }
  return parts;
}
function emitRest(ql,measureQL){
  const parts=[]; let rem=ql;
  while(rem>0){
    const take=Math.min(rem,measureQL); const div=qToDiv(take); const {type,dots}=durToType(div);
    let xml=`\n  <note><rest/><duration>${div}</duration><type>${type}</type>`; if(dots) xml+=`<dot/>`; xml+=`</note>`;
    parts.push({xml,ql:take}); rem-=take; if(rem>1e-6) parts.push({type:'bar'});
  }
  return parts;
}

/* ---------- VexFlow detection (no global touch until Engrave) ---------- */
function getVF(){
  // Try common globals across VexFlow 3.x / 4.x UMD builds
  const VF = (window.Vex && window.Vex.Flow) || window.Flow || window.VexFlow || null;
  if(!VF) throw new Error('VexFlow not found. The engraver can’t run. You can still export MusicXML.');
  return VF;
}

/* ---------- Engraving & PDF ---------- */
const vfPreview = document.getElementById('vfPreview');
function toVexDuration(q){
  const eps=1e-3, base=[[4,'w'],[2,'h'],[1,'q'],[0.5,'8'],[0.25,'16'],[0.125,'32']];
  for(const [qv,d] of base){ if(Math.abs(q-qv)<eps) return {dur:d,dots:0}; }
  for(const [qv,d] of base){ if(Math.abs(q-qv*1.5)<eps) return {dur:d,dots:1}; }
  let best=base.reduce((b,m)=>Math.abs(q-m[0])<Math.abs(q-b[0])?m:b, base[2]); return {dur:best[1],dots:0};
}
function midiToKey(m){ const s=['c','c#','d','d#','e','f','f#','g','g#','a','a#','b']; return s[m%12]+'/'+(Math.floor(m/12)-1); }
function renderVex(notes, plan){
  const VF = getVF(); // only now we touch VexFlow; if missing, this throws a clear error
  vfPreview.innerHTML=''; if(!notes.length) return;
  const width=900, height=120, staveW=width-40;
  // convert to quarter lengths & measure wrap
  const qps=plan.tempoBpm/60; const qNotes=notes.map(n=>({midi:n.midi, qlen: Math.max(1/plan.gridDen, Math.round((n.durSec*qps)*plan.gridDen)/plan.gridDen)}));
  const [beats, beatType]=plan.meter.split('/').map(Number); const measureQL=beats*(4/beatType);
  function split(qn){ const out=[], m=[], push=()=>{ if(m.length) out.push(m.splice(0)); }; let sum=0;
    for(const n of qn){ let rem=n.qlen, first=true; while(rem>1e-6){ const space=measureQL-sum; const take=Math.min(rem,space);
      m.push({midi:n.midi, qlen:take, tieStart:!first, tieStop:rem-take>1e-6}); sum+=take; rem-=take; first=false; if(Math.abs(sum-measureQL)<1e-6){ push(); sum=0; } } }
    if(m.length) out.push(m); return out; }
  const measures = split(qNotes);

  for(let i=0;i<measures.length;i+=4){
    const group=measures.slice(i,i+4);
    const svg=document.createElementNS('http://www.w3.org/2000/svg','svg'); svg.setAttribute('width',width); svg.setAttribute('height',height);
    vfPreview.appendChild(svg);
    const renderer=new VF.Renderer(svg, VF.Renderer.Backends.SVG); const ctx=renderer.getContext();
    let x=10, y=30;
    group.forEach((bar, idx)=>{
      const stave=new VF.Stave(x,y,staveW/group.length);
      if(idx===0){
        stave.addClef('treble'); stave.addTimeSignature(`${beats}/${beatType}`);
        const ks=(plan.keySignature||'C major').split(' ')[0]; const allowed=['C','G','D','A','E','B','F#','C#','F','Bb','Eb','Ab','Db','Gb','Cb'];
        if(allowed.includes(ks)) stave.addKeySignature(ks);
        const tempoText=new VF.StaveTempo({name:`${plan.tempoBpm} BPM`, duration:'q'}, -1); stave.setTempo(tempoText, 0);
      }
      stave.setContext(ctx).draw();
      const vfNotes=bar.map(n=>{
        const spec=toVexDuration(n.qlen);
        const note=new VF.StaveNote({keys:[midiToKey(n.midi)], duration:spec.dur});
        for(let d=0; d<spec.dots; d++) VF.Dot.buildAndAttach([note], {all:true});
        if(midiToKey(n.midi).includes('#')) note.addAccidental(0,new VF.Accidental('#'));
        return {note, tieStart:n.tieStart, tieStop:n.tieStop};
      });
      const voice=new VF.Voice({num_beats:beats,beat_value:beatType}).setStrict(false);
      voice.addTickables(vfNotes.map(x=>x.note)); new VF.Formatter().joinVoices([voice]).format([voice], stave.getWidth()-20);
      voice.draw(ctx, stave);
      for(let k=0;k<vfNotes.length;k++){
        const c=vfNotes[k]; if(c.tieStart && k>0){ const p=vfNotes[k-1]; new VF.StaveTie({first_note:p.note, last_note:c.note}).setContext(ctx).draw(); }
      }
      x+=stave.getWidth();
    });
  }
}

/* ---------- Analyze → Notes ---------- */
analyzeBtn.addEventListener('click', async ()=>{
  try{
    analyzeBtn.disabled=true; engraveBtn.disabled=true; downloadPdfBtn.disabled=true;
    statusEl.textContent='Preprocessing…';
    const work = vocalsBlob || srcBlob;
    if(!work){ alert('Upload or drag a file first (or run stem separation).'); analyzeBtn.disabled=false; return; }

    const pre = await preprocessAudioToBuffer(work);
    statusEl.textContent='Estimating f0 (CREPE)…';
    const f0 = await estimateF0TrackFromBuffer(pre);
    logln('f0 frames:', f0.length);

    const params={
      gridDen: parseInt(gridDen.value,10),
      minDurMs: parseInt(minDurMs.value,10),
      gapMs: parseInt(gapMs.value,10),
      vibratoSemi: parseFloat(vibratoSemi.value)
    };
    const notes = segmentNotesFromF0(f0, params);
    if(!notes.length) throw new Error('No notes detected — try a shorter/cleaner clip or run stem separation.');

    const tempo = tempoBpm.value ? parseFloat(tempoBpm.value) : estimateTempoBpm(notes);
    const keyStr = (forceKey.value.trim()==='' || forceKey.value.trim().toLowerCase()==='auto') ? detectKey(notes) : forceKey.value.trim();
    const meter = meterSel.value;

    lastNotes = notes;
    lastPlan = { meter, tempoBpm: tempo, keySignature: keyStr, gridDen: params.gridDen };
    statusEl.textContent=`Detected ${notes.length} notes | ${tempo} BPM | ${keyStr} | ${meter}`;
    engraveBtn.disabled=false;
  }catch(e){
    alert('Analyze failed: ' + (e.message||e));
    logln('Analyze ERROR:', e.message||e);
  }finally{
    analyzeBtn.disabled=false;
  }
});

/* ---------- Engrave + PDF ---------- */
engraveBtn.addEventListener('click', ()=>{
  try{
    if(!lastNotes.length){ alert('Run Analyze first.'); return; }
    renderVex(lastNotes, lastPlan);
    downloadPdfBtn.disabled=false;
  }catch(e){
    alert(e.message || 'Engrave failed.');
    logln('Engrave ERROR:', e.message||e);
  }
});
downloadPdfBtn.addEventListener('click', async ()=>{
  try{
    const svgs = Array.from(vfPreview.querySelectorAll('svg'));
    if(!svgs.length){ alert('Engrave first.'); return; }
    const { jsPDF } = window.jspdf;
    const doc=new jsPDF({orientation:'portrait',unit:'pt',format:'letter'});
    const pageW=doc.internal.pageSize.getWidth(), pageH=doc.internal.pageSize.getHeight();
    for(let i=0;i<svgs.length;i++){
      if(i>0) doc.addPage();
      const svg=svgs[i];
      const w=svg.width.baseVal.value||900, h=svg.height.baseVal.value||120;
      const scale=0.95*Math.min(pageW/w, pageH/h);
      await svg2pdf(svg, doc, {x:20, y:30, scale: isFinite(scale)? scale:1});
    }
    doc.save('vocal_lead_sheet.pdf');
  }catch(e){
    alert('PDF export failed: ' + (e.message||e));
    logln('PDF ERROR:', e.message||e);
  }
});

/* ---------- Stem server (HTTPS) ---------- */
healthBtn.addEventListener('click', async ()=>{
  try{
    const base=(stemUrl.value||'').trim().replace(/\/+$/,'');
    if(!base){ alert('Enter your ngrok/Cloudflare HTTPS URL.'); return; }
    if(!base.startsWith('https://')){ alert('Server URL must be HTTPS when the page is HTTPS.'); return; }
    const r = await fetch(base + '/healthz', {cache:'no-store'});
    if(!r.ok) throw new Error('HTTP '+r.status);
    const j = await r.json();
    alert('Stem server OK: model=' + j.model);
    logln('Health OK:', JSON.stringify(j));
  }catch(e){
    alert('Health check failed: ' + (e.message||e));
    logln('Health ERROR:', e.message||e);
  }
});

separateBtn.addEventListener('click', async ()=>{
  try{
    separateBtn.disabled=true; statusEl.textContent='Uploading to stem server…';
    const base=(stemUrl.value||'').trim().replace(/\/+$/,'');
    if(!base){ alert('Enter your HTTPS Server URL first.'); separateBtn.disabled=false; return; }
    if(!base.startsWith('https://')){ alert('Server URL must be HTTPS (GitHub Pages is HTTPS).'); separateBtn.disabled=false; return; }
    const f = srcBlob; if(!f){ alert('Upload or drag a file first.'); separateBtn.disabled=false; return; }

    const ping = await fetch(base + '/healthz').then(r=>r.ok?r.json():null).catch(()=>null);
    if(!ping || !ping.ok){ throw new Error('Stem server unreachable or not OK.'); }

    const fd = new FormData();
    const name=(f.name||'input.wav').replace(/[^a-z0-9_.-]/ig,'_');
    fd.append('audio', f, name);
    const res = await fetch(base + '/separate', { method:'POST', body: fd });
    if(!res.ok) throw new Error('HTTP '+res.status+' from stem server');
    vocalsBlob = await res.blob();
    player.src = URL.createObjectURL(vocalsBlob); player.load();
    statusEl.textContent='Vocal stem ready. Click Analyze → Notes.';
    logln('Stem OK: received', (vocalsBlob.size/1024/1024).toFixed(2), 'MB');
  }catch(e){
    alert('Stem separation failed: ' + (e.message||e));
    logln('Stem ERROR:', e.message||e);
  }finally{
    separateBtn.disabled=false;
  }
});
</script>
</body>
</html>

